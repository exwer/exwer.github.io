---
date: 2024-07-01

layout: post
title: "读书笔记   《网络是怎样链接的》"
date: 2021-07-01T11:00:00.000Z
last_modified_at: 2024-07-01T20:28:59.000Z
categories:
  - 技术 
tags:
---

# 介绍

- 作者: [日]户根勤
- 译者: 周自恒
- 适用范围：初级程序员入门、中级程序员查漏补缺、高级程序员教材

# 浏览器生成消息

## HTTP消息

### 不同的URL

输入的网址叫URL（Uniform Resource Locator，统一资源定义符号)，通常我们使用浏览器来访问web服务器，所以URL通常是http/https开头，并且包含服务器的域名和访问文件的路径名等。

但其实浏览器不止有访问web服务器这一个功能，而使用不同功能时的URL也会有所变化。

- 访问web服务：`http://user:password@www.galsscom.com:80/dir/file1.html`
- 使用ftp协议下载和上传文件: `ftp://user:password@ftp.glasscom.com:21/dir/file.html`
- 读取客户端本地文件：`file://localhost/c:/path/file.zip`
- 发送电子邮件：`mialto:tone@glasscom.com`

URL开头的部分代表了协议名，后面的写法各不相同，但协议名决定了后面的写法。

### 解析URL

如果URL以`/`结尾，说明它省略了要访问的文件名。这时候会访问该目录下的默认文件，根据服务器设置不同，默认的文件名不同，通常习惯为`index.html`或者`default.html`之类的。

同理也可以这样写：`http://www.lab.glasscom.com`，即彻底省略路径，这样也会访问根目录下的默认文件。

比较特殊的例子：`http://www.lab.glasscom.com/whatisthis`，这个例子省略了最后的`/`，这种情况会按照以下惯例处理：如果服务器上存在名为`whatisthis`的文件，则将`wahtisthis`按照文件名来处理；如果存在名为`whatisthis`的目录，则将它按照目录来处理。

HTTP向服务器发消息时，分为`对什么`和`要做什么`两个部分，其中`要做什么`就是HTTP的方法比如`GET`、`POST`，`对什么`就是URI。

HTTP消息的解析需要严格按照约定：

![image-20230313145848552](https://love-js-img-bed.oss-ap-northeast-1.aliyuncs.com/image-20230313145848552.png)

消息头中定义了很多标准，如`Cache-Control`、`User-Agent`等，每种头有不同的功能。

## DNS查询

浏览器生成HTTP消息后，需要委托操作系统来发送消息，因为发送消息对所有应用都是通用的，所以一般都由操作系统来实现。

### TCP/IP

TCP/IP组成网络是由小的子网通过路由器连接起来组成的，子网可以简单理解成用集线器连接起来的几台计算机，将它们看作一个单位，就称为子网。

![image-20230313151646358](https://love-js-img-bed.oss-ap-northeast-1.aliyuncs.com/image-20230313151646358.png)

发送的消息先经过子网的集线器，被转发到距离发送者最近的路由器上，接下来路由器会根据目的地判断下一个路由器的位置，然后将消息转发到下一个路由器，即消息再次经过子网集线器转发到下一个路由器。这个过程不断重复，直到消息被传送到目的地。

### IP的构成

IP地址主体：`10.11.12.13`，它是一串32bit的数字，按照8bit（1 byte）为一组分成4组，每组用十进制表示，并用圆点隔开。

IP地址由网络号和主机号构成，分别表示子网地址和子网中主机的地址。组成但凭这一串数字无法区分网络号和主机号，IP地址规则中，网络号和主机号连起来一共是32bit，但这两部分的具体结构是不固定的，在组建网络时，用户可以自行决定他们之间的分配关系，因此还需要另外的附加信息来表示IP地址的内部结构。

这种信息叫做子网掩码：`10.11.12.13/255.255.255.0`

|          | 十进制表示    | bit表示                             |
| -------- | ------------- | ----------------------------------- |
| IP地址   | 10.1.2.3      | 00001010.00000001.00000010.00000011 |
| 子网掩码 | 255.255.255.0 | 11111111.11111111.11111111.00000000 |

转换为bit后，子网掩码为0的部分对应的IP地址表示主机号，子网掩码为1的部分对应的IP地址表示网络号。

如在上面这个例子里，网络号是00001010.00000001.00000010，主机号是00000011。

所以，子网掩码表示网络号与主机号之间的边界，这个例子里，这个边界和字节的边界正好吻合，也就是刚好划分在句点的位置上，实际上也可以划分在字节的中间部分。

子网掩码也可以用十进制简写：`10.1.2.3/24`。

两种特殊情况：

- `10.11.12.0/24`：主机号部分的比特全部为0，这个地址表示的不是单独一台计算机，而是代表整个子网。
- `10.11.12.255/24`：主机号部分的比特全部为1，这个地址表示对整个子网进行广播。广播即向子网上所有设备发送包。

### DNS查询过程

DNS收到的查询信息包括三部分：

- 域名
- Class，最早设计DNS方案时，考虑了互联网以外的应用，但现在基本只有互联网了，所以这个字段的值永远是IN（互联网）
- 记录类型，表示域名对应何种类型的记录。比如值为A时，表示域名对应的是IP地址；值为MX时，表示域名对应的是邮件服务器。

DNS服务器上会保存这三种类型的记录数据，每条数据对应一个IP地址。

但现实中，数据分布在多台DNS服务器中，一个查询需要服务器之间接力配合。

DNS将域名按照句点来分割成不同的层级，每一层叫做**域**，越往后的层级越高，例如`www.lab.glasscom.com`中，`com`域最高，它的下一层是`glasscom`域，以此类推。每台DNS服务器可能存储着多个域的信息。

为了完成查询接力，负责管理下级域的DNS服务器的IP地址会被注册在它们的上级DNS服务器中，然后上级的服务器IP地址再注册到更上一级的DNS服务器中，例如负责管理`lab.glasscom.com`这个域的DNS服务器的IP地址需要注册到`glasscom.com`域的DNS服务器中，依此类推。

在`com`、`jp`这层域之上，还存在着一层隐藏的域，叫**根域**。根域在书写时经常被省略，如果要明确表示根域，需要在域名最后加个点：`www.lab.glasscom.com.`，最后这个点就代表根域。

理论上可以从根域出发找到任何一个域的DNS服务器。根域的IP地址被保存在所有DNS服务器中，它们只有13个。这样一来，任何一个DNS服务器都可以找到根域，然后通过根域找到目标DNS服务器。

现实中，不一定每次请求都这么麻烦，原因如下：

- 一台DNS服务器可以管理多个域的信息
- 上级域和下级域可以共享同一台DNS服务器
- DNS服务器有缓存功能，已经查询过的结果会存储在缓存中，所以不一定每次都从根域往下查，可以直接从缓存的结果开始查询，减少了查询路径；而为了保证数据一致，DNS缓存有过期时间

### 委托协议栈发送消息

1. 创建套接字阶段：调用Socket库中的socket组件，创建完成后，协议栈会返回一个描述符，一个计算机可以同时有多个套接字，描述符相当于每个套接字的身份标识。
2. 连接阶段：调用Socket库的connect组件，传入三个参数：描述符、服务器IP地址、端口号。如果说描述符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制。端口号的规则是事先约定好的，例如web服务是80端口，电子邮件服务是25端口，为了避免重复和冲突，端口号和IP地址一样，都是由IANA（Internet Assigned Number Authority，互联网编号管理局）这一组织来统一管理的。
3. 通信阶段：调用Socket库的write组件，传入描述符和要发送的数据，然后协议栈就会将数据发送到服务器。接下来服务器会接受、解析、返回消息。消息返回后，需要调用Socket库的read组件存放接收到的响应消息。
4. 断开阶段：HTTP协议规定，Web服务器发送完响应消息后，应该主动执行断开操作（实际上，根据应用种类不同，客户端和服务器端哪一方先断开都有可能），因此Web服务器会调用Socket库的close组件来断开连接。断开操作传到客户端后，read会告知浏览器连接已断开，浏览器得知后会调用close进入断开阶段。

HTTP协议每获取一次数据，就要执行一次连接、发送消息、接受响应消息、断开的全过程。HTTP又将HTML文档和图片都作为单独的对象来处理，这就导致这么一来有时效率会比较低下，因此后来又设计出了HTTP1.1、HTTP2.0等来改善这个机制。

## 用电信号传输TCP/IP数据——协议栈和网卡

### 协议栈的内部结构

以下为大致结构：

![image-20230315184306579](https://love-js-img-bed.oss-ap-northeast-1.aliyuncs.com/image-20230315184306579.png)

套接字在windows上的信息：

![image-20230315184833019](https://love-js-img-bed.oss-ap-northeast-1.aliyuncs.com/image-20230315184833019.png)

套接字和协议栈配合进行消息收发流程图：

![image-20230316115018159](https://love-js-img-bed.oss-ap-northeast-1.aliyuncs.com/image-20230316115018159.png)

### 协议栈收发数据

数据收发操作是从应用程序调用`write`将要发送的数据交给协议栈开始的。

协议栈并不是一收到数据就马上发送，而是将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据，因为应用程序交给协议栈发送的数据长度是应用程序本身决定的，所以一般会积累到一定量才会一起发出去。

要积累到多少来发送，不同种类和版本的操作系统处理不同，一般根据以下几个要素来判断：

- `MTU`参数：表示一个网络包的最大长度，在以太网中一般是1500 byte。`MTU`减去头部的长度叫`MSS`，它就是一个网络包中能容纳的最大数据长度。当收到应用程序的数据接近`MSS`再发出去，就可以避免发送大量小包。
- 时间：等待接收应用程序数据时间也不能太久，所以内部会有一个定时器，超过一定时间就会发送数据。

这两个要素互相矛盾，长度优先则因为等待时间导致延迟变高，时间优先则会因为每次长度太短降低网络效率。TCP没有规定一个完美的平衡，所以不同的操作系统实现不一样。

协议栈也给应用程序提供了控制发送时机的余地，应用程序在`write`时可以指定一些选项，比如“不等待填满缓冲区直接发送”等。

![image-20230321184855026](https://love-js-img-bed.oss-ap-northeast-1.aliyuncs.com/image-20230321184855026.png)

### 拆分包

如果传入缓冲区的数据超过了MSS的长度，此时就可以不用继续等待后续数据，而是将缓冲区中的数据按MSS的长度拆分，拆出来的每块都是一个单独的网络包。

当要发送数据时，就会对每块数据进行操作：

1. 在数据包前面加上TCP头部
2. 根据套接字中记录的控制信息，标记发送方和接收方的端口号
3. 交给IP模块来执行发送操作

大致如图：

![image-20230322190937737](https://love-js-img-bed.oss-ap-northeast-1.aliyuncs.com/image-20230322190937737.png)

### 连接的具体过程

### 使用ACK号确认网络包已收到

TCP需要具备确认对方是否收到网络包，以及当对方没收到时重发的功能，所以在发送网络包之后还需要额外的操作。

![image-20230327182619136](https://love-js-img-bed.oss-ap-northeast-1.aliyuncs.com/image-20230327182619136.png)

TCP拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，然后把这个字节数写在TCP头部的“序号”字段。

接下来，接收方可以检查网络包是否遗漏，例如上次接收到第1460字节，那么接下来应该应该接受到的是序号为1461的包。如果确认没有遗漏，接收方会将目前为止接收到的数据长度加起来，计算出一共收到了多少字节，然后将这个数据写入TCP头部的`ACK`字段中发送给发送方。这样，发送方就能确认对方收到了多少数据。

在实际中，序号不可能都是从1开始，因为这样可能被人利用来攻击，所以初始值一般都是随机的。所以在连接过程中，将`SYN`设为1的同时，也会同时设置一个序号字段的初始值。

由于TCP的收发是双向的，不止是客户端可以向服务器发送数据，服务器也可以向客户端发送数据，所以需要增加一种相反的情况：

![image-20230330191301005](https://love-js-img-bed.oss-ap-northeast-1.aliyuncs.com/image-20230330191301005.png)
