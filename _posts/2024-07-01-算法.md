---
title: 算法
author: exwer
date: 2024-07-01 16:30:02
categories:
  - 技术
tags:
  - 算法
updated: 2024-07-08 05:05:54
---

# 常见bug总结

- if内条件反/错
- 二维数组边界应该取length-1还是length，可能取错


# 链表
## 206.反转链表
### 迭代
链表题目迭代一定要考虑设置prev
```javascript
function reverse(head){
	if(head === null){
		return head	
	}
	let prev = null
	let cur = head
	
	while(cur){
		let next = cur.next
		cur.next = prev
		prev = cur
		cur = next
	}

	return prev
}
```

### 递归

```javascript
function reverse(head){
	if(head === null || head.next === null){
		return head	
	}
	let last = reverse(head.next)
	head.next.next = head
	head.next = null
	return last
}
```

## 21.合并有序链表
### 递归
```javascript
function mergeTwoList(l1,l2){
	//l1.next should be MAX(n.next,l2)
	//如果next不存在,则直接连接l2即可
	if(l1 === null){
		return l2
	}
	if(l2 === null){
		return l1
	}

	if(l1.val < l2.val){
		//由较小的一方链接剩下的结果
		l1.next = mergeTwoList(l1.next,l2)
		return l1
	}else{
		l2.next = mergeTwoList(l2.next,l1)
		return l2
	}
}
```

# 字符串

## 技巧
### KMP


## 415.字符串相加

```javascript
var addStrings = function(num1, num2) {
    let i = num1.length - 1
    let j = num2.length - 1
    let add = 0
    const ans = []

    while(i>=0 || j>= 0 || add > 0){
        const x = Number( i >= 0 ? num1.charAt(i) : '0') 
        const y = Number(j >= 0 ? num2.charAt(j) : '0')
        const sum = x + y + add
        ans.push(sum % 10)
        add = sum >= 10 ? 1 : 0 
        i -= 1 
        j -= 1
    }

    return ans.reverse().join('')
};
```

## 字符串相乘

# 二叉树

## 题目

### 257.二叉树的所有路径
在每条DFS路径上拼接一个path字符串，在叶子结点处push进结果

```javascript
function binaryTreePaths(root){
	const ans = []
	const traverse(root,str){
		str += root.val.toString()
		if(!root.left && !root.right){
			ans.push(str)
		}
		if(root.left){
			traverse(root.left,str+'->')
		}
		if(root.right){
			traverse(root.right,str+'->')
		}
	}
	traverse(root,'')

	return ans
}
```

### 113.路径总和II
#### 题干
给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

#### 思路
1.直接递归，每次分叉时使用不同的path
2.回溯法，使用同一个path，节省内存

#### 答案

```javascript
//思路1
function pathSum(root,targetSum){
	const ans = []
	const traverse = (root,path,sum)=>{
		if(!root)return

		//纪录当前节点
		path.push(root.val)
		//叶子结点
		if(!root.left && !root.right){
			if(sum === root.val){
				ans.push(path)	
			}
		}else{
			//Array.from克隆，避免路径交叉
			//这种操作导致每一个非叶子节点就得开辟一块新内存
			root.left && traverse(root.left,Array.from(path),sum - root.val)
			root.right && traverse(root.right,Array.from(path),sum - root.val)
		}
	}
	traverse(root,[],targetSum)
	return ans
}
//思路2 回溯优化版
function pathSum(root,targetSum){
	const ans = []
	const traverse = (root,path,sum)=>{
		if(!root)return

		//纪录当前节点
		path.push(root.val)
		//叶子结点
		if(!root.left && !root.right){
			if(sum === root.val){
				//在确定答案后生成一条新path,压入ans
				ans.push(Array.from(path))	
			}
		}else{
			//Array.from克隆，避免路径交叉
			//这种操作导致每一个非叶子节点就得开辟一块新内存
			root.left && traverse(root.left,path,sum - root.val)
			root.right && traverse(root.right,path,sum - root.val)
		}
		//每个节点处理完就pop掉当前结果
		//如果答案正确则已被记录，这样一直pop到新的路径上，重复利用path数组，避免内存消耗
		path.pop()
	}
	traverse(root,[],targetSum)
	return ans
}

```

### 687.最长同值路径
#### 题干
给定一个二叉树的 `root` ，返回 _最长的路径的长度_ ，这个路径中的 _每个节点具有相同值_ 。 这条路径可以经过也可以不经过根节点。

**两个节点之间的路径长度** 由它们之间的边数表示。

例如:
输入：root = [5,4,5,1,1,null,5]
输出：2

#### 思路
这道题其实是把二叉树当成图来看了，因为题目中一条路径没必要经过根节点和叶子结点，但是路径不能回头。
sit1：根左右值相同，那么此根的路径长度为 f(left) + f(right) + 1
sit2：如果根左右值都不相同，那么此根路径长度重制为0
sit3：根和其中一个子节点值相同，那么此根路径长度为 len(left or right) + 1
注意：在向上返回值时，只能返回其中一条路径的长度（因为不能回头），也就是sit1其实已经组成了一条完整路径，无法向上返回，可以直接判断答案。向上只能返回sit2或sit3的长度。

#### 答案
```javascript
function longestUnivaluePath(root){
	let ans = 0
	function traverse(root){
		//到空结点
		if(!root){
			return 0
		}
		let lLen = 0
		let rLen = 0
		let lPath = traverse(root.left)
		let rPath = traverse(root.right)
		//值相同时才连线
		if(root.left && root.val === root.left.val){
			lLen = lPath + 1	
		}
		if(root.right && root.val === root.right.val){
			rLen = rPath + 1	
		}
		//取左或右较长的一方和答案比对,并返回
		let longest = Math.max(lLen,rLen)
		ans = Math.max(ans,longest)

		//sit1：根左右值都相同，则已经构成一条回路，判断答案
		if(root.left && root.right &&root.val === root.left.val && root.val === root.right.val){
			ans = Math.max(ans, lLen + rLen)
		}

		return longest
	}
	traverse(root)
	return ans
}
```

### 572.另一棵树的子树
#### 思路
这道题的关键就是理解“子树”的概念，满足以下任意情况，则一棵树是另一棵树的子树：
- 两个树完全相同
- 一棵树是另一棵树的子树的子树
#### 答案
王道暴力dfs：
```javascript
function isSubTree(root,subRoot){
	//两棵树的终点应当一致，都为空
	if(!root){
		return !subRoot
	}

	//判断完全相同或子树
	return isSameTree(root,subRoot) || isSubTree(root.left,subRoot) || isSubTree(root.right,subRoot) 
}
function isSameTree(root,subRoot){
	//应同时穷尽
	if(!root && !subRoot)return true
	//仅一方穷尽则不相同
	if(!root || !subRoot)return false
	//当前节点和子孙节点值都应相同
	if(root.val === subRoot.val){
		return isSameTree(root.left,subRoot.left) && isSameTree(root.right,subRoot.right)
	}
	//否则就不相同
	return false
}
```

[[#KMP]]

### 236、1644、1650.公共祖先（LCA）系列

#### 思路

如果每个节点有一个parent指针（简单情况）：

​	一个节点从自身开始往上找，使用hashmap存储该节点的路径；接着另一个节点也从自身开始往上找，如果找到的parent存在于hashmap中，则该parent就是答案。

如果没有parent指针：

​	如果给出的两个节点必定在树中：

- 方法一：直接DFS寻找两个节点的路径，然后从左到右比较路径，最后一个相同的节点即为LCA。
- 方法二：假设给出的两个节点分别为A和B
  - 如果root === A 或 root === B，那么root就是LCA（因为剩下一个点一定是它的子节点）
  - 寻找root的left和right
    - 如果left和right都能各找到一个节点，那root就是LCA
    - 如果两边只找到了一个节点，直接返回该点

​	如果给出的节点不一定出现在树中：

- 方法一：同上
- 方法二：上述方法修改：每次递归要多返回两个boolean，分别代表是否找到A和B

```javascript
// 236.最近公共祖先
// 使用方法二
function lowestCommonAncestor(root,p,q){
	if(!root || root.val === p.val || root.val === q.val){
		return root
	}
	const left = lowestCommonAncestor(root.left,p,q)
	const right = lowestCommonAncestor(root.right,p,q)
	if(left && right){
		return root	
	}
	return left ? left : right
}
```

```javascript

```
### 114.二叉树展开为链表

### 109.有序链表转化为平衡BST
#### 思路
类似有序数组转化为BST，只需多加一步链表遍历成数组。
分治思想，因为有序，所以左<中<右，又因为要保持平衡，故每次取中点作为根，然后左右各为左区间和右区间的递归结果，注意`slice`使用时的边界问题。

#### 答案
```javascript
function sortedListToBST(head){
	const arr = []
	let ptr = head
	while(ptr){
		arr.push(ptr.val)
		ptr = ptr.next
	}
	return buildBST(arr)
}
function buildBST(arr){
	//但凡有一个元素都要继续构建，所以终点是0个元素
	if(arr.length === 0){
		return null
	}	
	let mid = Math.floor(arr.length/2)
	const root = new TreeNode(arr[mid])

	//左右区间，都不包含当前节点
	root.left = buildBST(arr.slice(0,mid))
	root.right = buildBST(arr.slice(mid+1))

	return root
}
```

### 98.验证二叉搜索树 & 99.恢复二叉搜索树

**二叉搜索树重要性质：BST中序遍历的节点值是递增的**

利用该性质，对BST进行中序遍历，过程中更新prev节点，如果prev节点的值大于当前节点的值，则说明它不是二叉搜索树。（验证）

#### 验证

```typescript
function isValidBST(root: TreeNode | null): boolean {
    let prev = -Infinity
    function traverse(root){
        if(!root)return true
        if(!traverse(root.left)){
            return false
        }
        if(root.val <= prev)return false
        prev = root.val
        return traverse(root.right)
    }
    return traverse(root)
};
```

#### 恢复

在99.恢复BST题目中，利用这个特性找到异常节点，将他们的值进行更换。

但这里有个隐藏的坑：异常的节点对可能是一组也可能是两组，我们要找的两个异常点其实是第一组的第一个点和最后一组的最后一个点。

```typescript
function recoverTree(root: TreeNode | null): void {
    let prev:TreeNode = new TreeNode(-Infinity)
    let n1 
    let n2
    let tmp
   function traverse(root:TreeNode){
        if(!root)return
        traverse(root.left)
        if(prev.val > root.val){
            //异常
            if(!n1){
                n1 = prev
            }
            n2 = root
        } 
        prev = root
        traverse(root.right)
   } 
   traverse(root)

    tmp = n1.val
    n1.val = n2.val
    n2.val = tmp

};
```

### 100.平衡二叉树

### 103.二叉树的锯齿形层序遍历

本题BFS和DFS均可，要点是偶数层从左到右，奇数层相反，对应到代码则是`push`和`shift`

#### BFS

```javascript
function zigzagLevelOrder(root: TreeNode | null): number[][] {
   const ans = [] 
    if(!root)return ans
   const q = [root]
   let isOrderLeft = true
   while(q.length){
    const vals = []
    for(const _ of Array.from({length:q.length})){
        const node = q.shift()
        if(isOrderLeft){
            vals.push(node.val)
        }else{
            vals.unshift(node.val)
        }
        if(node.left)q.push(node.left)
        if(node.right)q.push(node.right)
    }
    isOrderLeft = !isOrderLeft
    ans.push(vals)
   }
   return ans
};
```

#### DFS

```javascript
function zigzagLevelOrder(root: TreeNode | null): number[][] {
    const ans = []
   function tra(n,dep){
    if(!n)return
    const isOrderLeft =  dep % 2 === 0
    if(!ans[dep])ans[dep] = []
    if(isOrderLeft){
        ans[dep].push(n.val)
    }else{
        ans[dep].unshift(n.val)
    }
    tra(n.left,dep+1)
    tra(n.right,dep+1)
   } 
   tra(root,0)
   return ans
};
```




# BFS
## 使用场景
- 连通块问题
	- 通过一个点找到图中联通的所有点
	- 非递归方式找到所有方案
- 分层遍历
	- 图的层次遍历
	- 简单图的最短路径
- 拓扑排序
	- 求任意拓扑序
	- 求是否有拓扑序（有向无环图）
	- 求字典序的最小拓扑序
	- 求是否唯一拓扑序
## 理念
- 使用队列，每访问一个节点，入队它的孩子节点

- 大部分情况下重复BFS无意义

  - 对于连通块问题，不可能找到新的节点
  - 对于最短路问题，不可能带来最短的路径

- 使用哈希表去重（visited）

- 若图中存在环，则同一个节点可能重复进入队列（有权图，最便宜飞机票问题）

## 解题模板
```javaScript
// step 1 初始化
// 把初始节点放到q里，如果有多个就都放进去
// 标记初始节点的距离为0，记录在distance的dict里
// distance有两个作用，一是判断是否已访问过，二是记录节点距离
const q = [node]

const distance = {[node]: 0}
//不需要距离时 const visited = new Set([node])

// step 2 不断访问队列
// while + 每次pop队列中的一个节点
while(q.length){
    // step 2.5 加一个循环用来分层,由于每次还在增加q的长度，所以这个循环次数要根据当前层的初始长度创建（可选） 
    for(const _ of Array.from({length: q.length})){
        const node = q.shift()
        // step 3 拓展相邻节点
    	// pop出的节点的相邻节点，加入队列并在distance中存储距离
        for (const neighbor of node.getNeighbors()){
            if(neighbor in distance){
                continue
            }
            distance[neighbor] = distance[node] + 1
            q.push(neighbor)
        }
    }
}
```

```typescript
// 拓扑排序模板
// step1 统计每个点的入度，构建graph和inDegree
// step2 将每个入度为0的点放入队列
// step3 不断地从队列中拿出一个点，去掉这个点的所有连边（指向其他点的边），其他点的入度-1
// step3.5 如果出队时，队列长度>1，说明不止有一种拓扑排序
// step4 一旦发现新的入度为0的点，丢进队列中
```

 ## 题目

### 108.word ladder 单词接龙

简单图的最短路径

#### 题干

在字典（单词列表） `wordList` 中，从单词 `beginWord` 和 `endWord` 的 **转换序列** 是一个按下述规格形成的序列：

- 序列中第一个单词是 `beginWord` 。
- 序列中最后一个单词是 `endWord` 。
- 每次转换只能改变一个字母。
- 转换过程中的中间单词必须是字典 `wordList` 中的单词。

给定两个长度相同但内容不同的单词 `beginWord` 和 `endWord` 和一个字典 `wordList` ，找到从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目** 。如果不存在这样的转换序列，返回 0。

**示例 1：**

```
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：5
解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。
```

**示例 2：**

```
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
输出：0
解释：endWord "cog" 不在字典中，所以无法进行转换。
```

#### 注意点

- `endWord`要先加入到`dict`中
- 最短路径问题，点不能重复
- 分层遍历，一旦在某一层找到结果，可以直接返回长度（后续的节点长度一定是大于等于当前结果的）
- `distance`初始值可以是0或1，这个要和return位置对应（在当前层return或在下一层return）；`distance`要在每一层开始时+1
- 边界情况：bfs搜索失败后应返回0
- `get_neighbors`可以是和`dict`里单词一一匹配（两层循环），也可以把单词某个h部分替换为a-z字母（一层循环），再判断替换后是否在`dict`中。这两种方法的时间复杂度分别是`O(NL)`和`O(L²)`（`N`为`dict`长度，`L`为单词长度，第二种方法主要是构建新字符串会消耗一个L时间）。一般来讲，O(L²)会更优，因为dict可能很长，但英语单词一般不会特别长。

#### 答案

```typescript
function getNeighbor(word,dict){
    const neighbors = []
    // 依次和dict中每一个单词作比较
    dict.forEach((child)=>{
       //依次比对每个字母，如果不同数目为1，则是neighbor 
       let diff = 0
       for(let i=0;i<word.length;i++){
            if(word[i] !== child[i] && diff<2){
                diff += 1
            } 
       }
       if(diff === 1){
            neighbors.push(child)
       }
    })  
    return neighbors
}
function ladderLength(beginWord: string, endWord: string, wordList: string[]): number {
    if(!wordList.includes(endWord)){
        return 0
    }
    const q = [beginWord]
    const visited = new Set([beginWord])
    let distance = 0
    while(q.length){
        distance += 1
        for(const _ of Array.from({length:q.length})){
            const node = q.shift()
            if(node === endWord){
                return distance
            }
            for(const neighbor of getNeighbor(node,wordList)){
                if(visited.has(neighbor)){
                    continue
                }
                q.push(neighbor)
                visited.add(neighbor)
            }
        }
    }
    return 0
};
```

### 200. Number of Islands 岛屿数量

二维数组的bfs/连通块

#### 题干

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

#### 答案

```typescript
function numIslands(grid: string[][]): number {
    // m = 1,n = 0
    if(grid[0].length === 0){
        return 0
    }
    const q = [] 
    const visited = []
    for(let i=0;i<grid.length;i++){
        for(let j=0;j<grid[i].length;j++){
            if(!visited[i]){
                visited[i] = []
            }
            visited[i][j] = false
        }
    }
    let count = 0

    for(let i=0;i<grid.length;i++){
        for(let j=0;j<grid[i].length;j++){
            if(visited[i][j]){
                continue
            }
            if(grid[i][j] === "0"){
                continue
            }
            //console.log(i,j)
            count += 1
            q.push([i,j])
            //bfs
            while(q.length){
                const node = q.shift()
                for(const neighbor of getNeighbors(node,visited,grid)){
                   q.push(neighbor) 
                   visited[neighbor[0]][neighbor[1]] = true
                }
            }
        }
    }
    return count
};
function getNeighbors(node:[number,number],visited:string[][],grid:string[][]){
    const m  =grid.length - 1
    const n = grid[0].length - 1
   //x+1,y  x-1,y  x,y+1 x,y-1
   const x = node[0]
   const y = node[1]
   const neighbors = []
   for(const neighbor of [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]){
    const deltaX = neighbor[0]
    const deltaY = neighbor[1]
    //out of boundary
    if(deltaX < 0 || deltaX > m)
        continue
    if(deltaY < 0 || deltaY > n)
        continue
    // ocean
    //console.log(deltaX,deltaY)
    if(grid[deltaX][deltaY] === '0')
       continue
    // visited
    if(visited[deltaX][deltaY])
        continue
    neighbors.push(neighbor)
   }

   return neighbors
}
```

 ### 207.课程表

求是否有拓扑排序/任意拓扑排序

#### 题干

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

**示例 2：**

```
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```

**提示：**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` 中的所有课程对 **互不相同**

#### 答案

```typescript
function canFinish(numCourses: number, prerequisites: number[][]): boolean {
   //算度数
   //找出0点入队
   //存结果,去连线，入度新0点 
   const q = []
   const graph:Record<number,number[]> = {}
   const inDegree = []
   for(let i=0;i<numCourses;i++){
    graph[i] = []
    inDegree[i] = 0
   }
   const ans = []
   for(const edge of prerequisites){
    graph[edge[1]].push(edge[0])
    inDegree[edge[0]] += 1
   }

   for(let i=0;i<inDegree.length;i++){
        if(inDegree[i] === 0){
            q.push(i)
        }
   }

   while(q.length){
    const course = q.shift()
    ans.push(course)
    for(let i=0;i<graph[course].length;i++){
       const nextCourse = graph[course][i] 
        inDegree[nextCourse] -= 1
       if(inDegree[nextCourse] === 0){
        q.push(nextCourse)
       }
    }
   }
   return ans.length === numCourses
};
```

### 444.序列重建

是否唯一拓扑序列

#### 题干

给定一个长度为 `n` 的整数数组 `nums` ，其中 `nums` 是范围为 `[1，n]` 的整数的排列。还提供了一个 2D 整数数组 `sequences` ，其中 `sequences[i]` 是 `nums` 的子序列。
检查 `nums` 是否是唯一的最短 **超序列** 。最短 **超序列** 是 **长度最短** 的序列，并且所有序列 `sequences[i]` 都是它的子序列。对于给定的数组 `sequences` ，可能存在多个有效的 **超序列** 。

- 例如，对于 `sequences = [[1,2],[1,3]]` ，有两个最短的 **超序列** ，`[1,2,3]` 和 `[1,3,2]` 。
- 而对于 `sequences = [[1,2],[1,3],[1,2,3]]` ，唯一可能的最短 **超序列** 是 `[1,2,3]` 。`[1,2,3,4]` 是可能的超序列，但不是最短的。

*如果 `nums` 是序列的唯一最短 **超序列** ，则返回 `true` ，否则返回 `false` 。*
**子序列** 是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。

**示例 1：**

```
输入：nums = [1,2,3], sequences = [[1,2],[1,3]]
输出：false
解释：有两种可能的超序列：[1,2,3]和[1,3,2]。
序列 [1,2] 是[1,2,3]和[1,3,2]的子序列。
序列 [1,3] 是[1,2,3]和[1,3,2]的子序列。
因为 nums 不是唯一最短的超序列，所以返回false。
```

**示例 2：**

```
输入：nums = [1,2,3], sequences = [[1,2]]
输出：false
解释：最短可能的超序列为 [1,2]。
序列 [1,2] 是它的子序列：[1,2]。
因为 nums 不是最短的超序列，所以返回false。
```

**示例 3：**

```
输入：nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]
输出：true
解释：最短可能的超序列为[1,2,3]。
序列 [1,2] 是它的一个子序列：[1,2,3]。
序列 [1,3] 是它的一个子序列：[1,2,3]。
序列 [2,3] 是它的一个子序列：[1,2,3]。
因为 nums 是唯一最短的超序列，所以返回true。
```

#### 答案

```typescript
```

### 269. 火星词典

#### 题干

现有一种使用英语字母的火星语言，这门语言的字母顺序对你来说是未知的。

给你一个来自这种外星语言字典的字符串列表 `words` ，`words` 中的字符串已经 **按这门新语言的**

**字典序**

**进行了排序** 。

如果这种说法是错误的，并且给出的 `words` 不能对应任何字母的顺序，则返回 `""` 。

否则，返回一个按新语言规则的 **字典递增顺序** 排序的独特字符串。如果有多个解决方案，则返回其中 **任意一个** 。



**示例 1：**

```
输入：words = ["wrt","wrf","er","ett","rftt"]
输出："wertf"
```

**示例 2：**

```
输入：words = ["z","x"]
输出："zx"
```

**示例 3：**

```
输入：words = ["z","x","z"]
输出：""
解释：不存在合法字母顺序，因此返回 "" 。
```

 

**提示：**

- `1 <= words.length <= 100`
- `1 <= words[i].length <= 100`
- `words[i]` 仅由小写英文字母组成
